/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export type JsClient = Client
/** Represents a client for the Autonomi network. */
export declare class Client {
  /** Initialize the client with default configuration */
  static init(): Promise<JsClient>
  /** Initialize a client that is configured to be local */
  static initLocal(): Promise<JsClient>
  /** Initialize a client that bootstraps from a list of peers */
  static initWithPeers(peers: Array<string>): Promise<Client>
  /** Get a chunk from the network */
  chunkGet(addr: JsChunkAddress): Promise<Buffer>
  /** Manually upload a chunk to the network */
  chunkPut(data: Buffer, paymentOption: JsPaymentOption): Promise<ChunkPutResult>
}
export declare class ChunkPutResult {
  get cost(): string
  get addr(): JsChunkAddress
}
export type JsXorName = XorName
/**
 * A 256-bit number, viewed as a point in XOR space.
 *
 * This wraps an array of 32 bytes, i. e. a number between 0 and 2<sup>256</sup> - 1.
 *
 * XOR space is the space of these numbers, with the [XOR metric][1] as a notion of distance,
 * i. e. the points with IDs `x` and `y` are considered to have distance `x xor y`.
 *
 * [1]: https://en.wikipedia.org/wiki/Kademlia#System_details
 */
export declare class XorName {
  /** Generate a XorName for the given content. */
  static fromContent(content: Uint8Array): JsXorName
}
export type JsChunkAddress = ChunkAddress
/**
 * Address of a chunk.
 *
 * It is derived from the content of the chunk.
 */
export declare class ChunkAddress {
  /** Creates a new ChunkAddress. */
  constructor(xorName: XorName)
  /** Returns the XorName. */
  xorname(): XorName
  /** Returns the hex string representation of the address. */
  toHex(): string
  /** Creates a new ChunkAddress from a hex string. */
  static tryFromHex(hex: string): JsChunkAddress
}
export type JsWallet = Wallet
/** A wallet for interacting with the network's payment system */
export declare class Wallet {
  /** Creates a new Wallet based on the given Ethereum private key. It will fail with Error::PrivateKeyInvalid if private_key is invalid. */
  static newFromPrivateKey(network: JsNetwork, privateKey: string): JsWallet
  /** Returns a string representation of the wallet's address */
  address(): string
  /** Returns the raw balance of payment tokens in the wallet */
  balance(): Promise<string>
  /** Returns the current balance of gas tokens in the wallet */
  balanceOfGas(): Promise<string>
}
export type JsPaymentOption = PaymentOption
/** Options for making payments on the network */
export declare class PaymentOption {
  static fromWallet(wallet: Wallet): JsPaymentOption
  static fromReceipt(): JsPaymentOption
}
export type JsNetwork = Network
export declare class Network {
  constructor(local: boolean)
}
